上节课工具
    进度条程序
    git工具
gdb调试
    gdb和windows调试的操作方式一定有区别
    gdb和linux调试的思路没有区别-->命令行调试 要求常见的调试命令会
默认情况下 gbd无法对现在发行的程序进行调试
    gcc/g++默认就是release版本，无法进行调试。（gcc默认行为是动态链接/默认是release) (vim默认就是命令行模式)
    debug:
    release:
    为什么要有这两个版本呢？程序员需要调试
                            用户关心软件好用不          release<debu
readelf 是一个专门用于分析 ELF 文件格式（Executable and Linkable Format）的命令行工具。
ELF 是 Linux 下常见的可执行文件、目标文件（.o）、共享库（.so）格式。
ELF 文件格式（Executable and Linkable Format）

gdb调试需要给编译器添加-g标识 让编译器一debug发布  -g Generate debugging information


GDB进行调试代码。
调试的方法和windows有区别吗？一定是有区别的！
调试的思路和windows有区别吗？一定是没有的！命令行调试！

如何进行GDB调试
| 命令                    | 说明            |
| --------------------- | ------------- |
| `run` 或 `r`           | 启动程序          |
| `break 行号` 或 `b 行号`   | 设置断点          |
| `break 函数名`           | 在函数入口设置断点     |
| `info breakpoints`    | 查看当前断点        |
| `delete 断点号`          | 删除某个断点        |
| `continue` 或 `c`      | 程序继续运行直到下一个断点 |
| `next` 或 `n`          | 单步执行（不进入函数）   |
| `step` 或 `s`          | 单步执行（会进入函数）   |
| `finish`              | 运行到当前函数返回     |
| `print 变量名` 或 `p 变量名` | 打印变量值         |
| `display 变量名`         | 每次停下时都自动显示变量值 |
| `list` 或 `l`          | 查看源代码         |
| `quit` 或 `q`          | 退出 GDB        |

默认情况下GDB不能够进行直接调试。
debug:debug版本才能调试，debug版本是为了给程序员看
release:不能够调试，给用户看
gcc默认是动态链接
gcc默认是release
vim默认是命令模式
gdb调试需要给编译器添加-g标识 让编译器一debug发布  -g Generate debugging information

readelf 读取文件信息·
编译代码添加-g选项

l默认显示10行代码，l 0从第零行开始显示

b 行号 打断点
info b 查看断点
d num 去掉断点
r 就是运行
n 逐过程
s 逐语句
c 直接进入下一个断点
bt:查看调用堆栈
fin 
p 变量名 显示一次
display 变量名 长显示
udisplay num

until  行数，跳出循环

F5:断点处停下来
C  F5:直接跑程序

逐语句:
逐过程：

yum
vim
gcc/g++
makefile
进度条
git

接下来系统编程
注意！！！接下来就是系统层面。
地址空间
    进程地址空间
    文件
    多线程

冯诺依曼体系结构
    输入设备                 存储器                                输出设备
                         运算器和控制器
    1.存储器就是所谓的内存。掉电易失去。
    2.磁盘就是外存，永久存储能力。属于外部设备。
    3.磁盘和网卡即是输入设备也是输出设备。单纯的输入\输出设备。
    4.外设是相对于内存和CUP来说的。冯氏理论。
    5.运算器+控制器+其他=cpu。相对于其他设备很快。
        CPU    快           计算的（计算的时候需要数据），CPU其实很笨。          只能被动的接收别人的指令，别人的数据，-->执行别人的指令，计算别人的数据。
                                                                                                                CPU执行，必须先认识指令。有自己的指令集。
                                                                                                                我们写代码，编译的本质就是形成二进制可执行程序-->形成指令。
                                                                                                                CPU在设计之初已经设计好了指令。
                                                                                                                精简指令集，复杂指令集。指令周期。
                                                                                                                CPU的数据从哪里来呢？内存。
                                                                                                                CPU只和内存打交道！主要是为了提高效率。
        内存   较快         临时存储                                内存天然没有数据，先从外部设备加载到内存里面。
                                                                    开机时就预先加载一批数据。大大的缓冲区域。
                                                                    这样子解决了速度不匹配的问题。

                                                                    操作系统管理操作的数据。
                                                                    I/O,内存读写数据。
        外设   较慢         永久存储
        数量级别的差别    
    6.

数据层面
1.CPU不和外设直接打交道，和内存直接打交道
2.所有的外设有需要数据载入，只能载入到内存中，内存写出也一定是写到外设里面。
3.CPU不和外设打交道。只和内存打交道。
    程序要运行必须加载到内存。
    CPU要执行我的代码，访问我的数据。只能从内存读取。
    

进度条：数据写到内存，只不过还没有刷新。


我--------------------------其他人
网卡也是输出输入设备。


操作系统是一款软硬件资源管理的软件。
为用户提供良好的执行环境。稳定，高效，安全的执行环境。
怎么管理？不需要面对面执行管理。
管理是需要有依据的。根据数据决策。

管理的本质就是对数据进行管理。




用户：
操作系统：进程管理，文件系统，内存管理，驱动管理。
硬件驱动：
硬件： 冯诺依曼体系












