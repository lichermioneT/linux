环境变量
mian函数参数

全局变量，子进程可以继承
局部变量，当前终端生效

main函数参数
让进程执行不同的功能
main函数数组表
指针数组表

getenv获取环境变量


高地址
----------------------------------


------------------------------------
堆区
-------------------------------------





-----------------------------------
栈区
----------------------------------
未初始化全局区
-----------------------------------
已经初始全局区
----------------------------------
代码区域
----------------------------------
低地址

这是虚拟地址

虚拟地址空间是每个进程看到和使用的一组地址范围，
它看起来就像是独立、连续的一大块内存，但实际上这些地址被映射到物理内存、磁盘或其他设备。




| 作用                                       | 解释                                                          |
| ---------------------------------------- | ----------------------------------------------------------- |
| **1. 每个进程拥有独立地址空间**                      | 每个进程有自己独立的虚拟地址空间，互不影响。比如，两个进程中变量的地址虽然相同，但指向的是**各自不同的物理内存**。 |
| **2. 增强系统安全性**                           | 因为进程间互相不能直接访问对方的内存，避免了非法访问、数据泄露、程序破坏等问题。                    |
| **3. 简化内存管理**                            | 开发者不需要关心物理内存有多少，直接使用虚拟地址空间，操作系统会自动处理地址映射。                   |
| **4. 支持内存映射文件（mmap）和共享内存**               | 虚拟内存机制支持把文件映射到内存，提高读写效率；也可以让多个进程共享一块物理内存。                   |
| **5. 提供更大空间（逻辑上）**                       | 比如 32 位系统最多支持 4GB 虚拟地址空间，而物理内存可能远小于这个数。虚拟地址空间打破了物理内存的限制。    |
| **6. 支持按需加载（Lazy Load）和换页机制（Page Swap）** | 虚拟内存可以配合磁盘，通过分页机制在需要时加载程序或数据，提高资源利用率。                       |
| **7. 支持堆栈空间自动增长**                        | 虚拟地址空间允许堆和栈动态扩展（操作系统设置保护页实现），避免程序崩溃。                        |





struct mm_struct
{
    





}

// 地址空间描述的基本空间大小是字节 
32位-----2的32次方
2^32 * 1字节 == 4gb

2的32次方个地址：只要保证唯一性就行了
32位的数据即可

FFFF FFFF
0000 0000


描述空间
struct desktop
{

    unsigned int mam_start;
    unsigned int mam_end;

    unsigned int nv_start;
    unsigned int nv_end;

    
}

struct desktop d = {1, 50, 51, 100};
如何调整

struct desktop d = {1, 45, 55, 100};
struct desktop d = {1, 30, 31, 100};

unsigned int (32位)
struct mm_struct
{
    uint32_t code_start,code_end;
    uint32_t data_start,data_end;
    uint32_t heap_start,heap_end;
    uint32_t stack_start,stack_end;
}

*mm =  malloc(struct  mm_struct)
区域的起始地址
区域的结束地址
mm->code_end
mm->code_start

mm->data_end
mm->data_start

mm->heap_end 
mm->heap_start

mm->stack_end 
mm->stack_start 

堆和栈区域是不断变化的，不是固定的空间大小
start-end 之间就是虚拟地址
heap && stack所谓的区域调整，本质就是修改end  start
定义局部变量 malloc new --->扩大对heap或者 stack
函数调用完毕 free---->缩小heap 或者stack

task_struct
{

    // 进程地址空间
    struct mm_struct* mm;



}


进程地址空间

 15 高地址
 16 ----------------------------------
 17 
 18 
 19 ------------------------------------
 20 堆区
 21 -------------------------------------
 22 
 23 
 24 
 25 
 26 
 27 -----------------------------------
 28 栈区
 29 ----------------------------------
 30 未初始化全局区
 31 -----------------------------------
 32 已经初始全局区
 33 ----------------------------------
 34 代码区域
 35 ----------------------------------
 36 低地址

 虚拟内存 页表 内存
每个进程都有一个页表吗每个进程都有一个页表吗
是的，✅ 每个进程都有自己的页表，用于将该进程的虚拟地址空间映射到物理内存。
和自己的地址空间

什么是地址空间呢？
虚拟地址==线性地址

为什么存在进程地址空间？
1.如果让进程直接访问物理内存，万一进程越界非法操作呢？为了安全
    页表不仅仅只做映射,还会检查安全性的。
2.地址空间的存在，可以更加方便的进行进程和进程的数据代码的解耦，保证了进程独立性的特征, 页表
3.!!!!!让进程以统一的视角，来看待进程对应的代码和数据等各个区域
        方便编译器也以统一的视角来进行编译代码
        规则一样的，编完可以直接使用
        ELF

    
    可执行程序里面有地址吗？没有加载到内存的时候。
    内部早就有地址啦。逻辑地址
    linux虚拟地址就是逻辑地址

    虚拟地址空间，os/编译器也要遵守相应的规则
        编译器编译你的代码的时候，就是按照虚拟地址空间的方式进行对我们的代码进行编地址的， 
    上面的地址，是我们程序内部使用的地址()
    程序加载到内存里面，天然就具有一个外部的物理地址了  


    表示物理内存在代码和数据的地址：加载到内存时的地址
    程序内部互相跳转的时候---虚拟地址：读取程序的地址
    虚拟地址和物理地址对应

    加载到内存是存放的实际地址：
    读取的程序是的地址是虚拟地址
    虚拟地址跳转到实际地址

    代码编译链接完成时候时逻辑地址
| 你说的表达                         | 更专业表述       |
| ----------------------------- | ----------- |
| “虚拟地址通过页码链接到物理地址”             | ✅ 稍不严谨，但方向对 |
| “虚拟地址通过**页表映射**链接到物理地址，按页为单位” | ✅ 更专业且准确    |



进程具体独立性
进程 = 内核数据结构 + 进程对应的代码和数据

进程控制
所有的进程放在一张哈希表里面的。

fork的返回值问题
1.怎么理解有两个返回值的问题
    fork函数是函数吗？实现在哪里呢。
    
    父进程和子进程各自的return语句
2.






































虚拟地址 页表 物理地址
c/c++取出来的是虚拟地址









环境变量具有全局属性，可以被子进程继承下去
环境变量和命令行参数



1.地址空间基本地址是字节
2.32位地址 2^32次方---4GB空间范围
3.每个字节都要有唯一的地址
    32位数据即可



































