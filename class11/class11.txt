操作系统拿到硬件的数据信息管理,并不需要面对面就行管理
管理的本质：是对数据进行管理
管理者：做决策  根据数据进行决策 操作系统
执行者：做执行  拿到数据         驱动层(显卡驱动，磁盘驱动，键盘驱动) 硬件都需要驱动程序
被管理者：产生数据               硬件

os:通过数据进行管理,先描述数据-->面向对象，在组织-->数据结构。
驱动：采集数据和决策的执行
硬件：听话执行。          一旦数据多了

所有的管理的本质：先描述，在组织。
例子：写一个通讯录，1先构建抽象成一个类，2先描述，组织起来。


结论：管理的本质是对数据进行管理。管理的方法是先描述，在组织。
描述是编程语言，组织方式是数据结构。

软件能够管理硬件，软件也能够管理软件。通用也是先描述后组织。


操作系统也不相信任何人！
但是也必须给上层用户提供服务。操作系统接口。操作系统调用。
linux就是c式的接口。os通过c语言提供给我们的函数调用。 

如何看待现在学习的编程。

系统进程！
什么是进程？
一个运行起来的程序（加载到内存）就是一个--进程
在内存中的程序--进程

程序的本质就是文件，在磁盘上放着呢。
文件加载到内存里面。
太多的程序，操作系统如何管理这些程序。多个程序管理起来呢？管理：先描述，后组织。

先描述--PCB概念。linux是struct task_struct {进程里面的属性，该进程的对应的代码和属性地址} 
PCB：Process Control Block（进程控制块）

在组织。所谓进程管理：变成了对进程对应的PCB进行相应的管理。
对进程的管理工作->对链表的增删查改。

struct task_struct 

进程 = 内核数据结构 + 进程对应的磁盘代码。

为什么会有PCB（struct task_struct）结构体呢？

进程属性
ps-->process status 进程状态
ps ajx | grep "test"

进程在运行的时候就具有动态属性!
见见系统调用。



man 2 getpid


另一个查看进程的方式

/proc 这是一个存放进程的目录 proc-->process

进程在运行的时候，删除磁盘的文件，进程可以运行。

进程常见的调用
getpid  子进程
getppid 父进程,命令行上启动的进程就是bash。

fork 


同一个变量不被修改的情况下，有两个返回值。
forK之后 会有父进程和子进程两个进程在执行后续的代码
fork后续的代码，被父子进程共享
通过不同的返回值，让父子进程后续共享代码的一部分

计算机的软硬件体系结构 
用户
shell lib(c/c++) 界面 操作指令
操作系统提供的接口，简称系统调用。操作系统接口。本质是就是c式的接口。c语言函数。必须都是系统提供给你的！！！！
操作系统
软件驱动
硬件

管理者   做决策    根据数据做决策
执行者： 做执行    拿到数据
被管理者：产生数据  



1.校长通过对数据进行管理，来进行被管理者进行管理
2.数据的采集和决策执行，由辅导员来做
3.数据量太大了？怎么解决？
    管理学生，要的信息都是一样的！虽然数据多。
    struct stu{
        name;
        sex;
        address;
        telephone;
        qq;
        score;
        struct* next;
    }
    struct stu zhangsan;
    struct stu lisi;

先描述，再组织。
先描述c++就是面向对象。 ---->数据结构管理。
先描述c语言就是面向过程。

所有的管理的本质就是先描述，后组织。
例子：写通讯录，先构建对应的struct的数据结构。
c++写一个类，list组织起来。
数据结构很重要的！！！！！！！！！！！！！！！！！！！！

管理的本质：对数据进行管理
管理的方法，先描述，后组织。
先描述，语言。组织方法就是数据结构。
同样软件可以管理软件。 
操作系统不相信任何人。非常容易受到伤害，所以要将自己保护起来。
操作系统既要将自己保护起来，又要给用户提供服务。
现在学习的内容，











         +--------+
         | 创建中 |
         +---+----+
             |
             v
         +---+----+
         | 就绪态 |
         +---+----+
             |
      CPU调度 |
             v
         +---+----+
         | 运行中 |
         +---+----+
          /   \
    时间片到    I/O请求等
        /         \
       v           v
  +----+---+   +---+----+
  | 就绪态 |   | 阻塞态 |
  +--------+   +--------+
                   |
                I/O完成
                   v
               +---+----+
               | 就绪态 |
               +--------+

什么是进程？
    一个运行起来（加载到内存里面）的程序教程程序。
    在内存中的程序--进程
    进程和程序相比，进程具有动态属性。

太多的程序添加到内存里面，操作系统如何管理操作加载进来的程序？
PCB的概念，进程控制块，先描述
struct task_struct{
    // 该进程的所有属性

}

组织起来。

所谓对进程进行管理，变成了对进程对应的PCB进行相关的管理
进程管理-->变成对链表的增删查改。
    
    struct  task_struct{} 内核结构体--> 创建相应的的对象-->该结构和你的代码数据关联起来
    进程 == 内核数据结构 + 进程对应的磁盘代码。

为什么会有PCB(task_struct)这样子的结构体呢？

见一见进程
process status 进程状态
ps ajx | grep 
| 字母  | 对应词          | 记忆点        |
| --- | ------------ | ---------- |
| `a` | **all**（所有）  | 所有用户的进程    |
| `j` | **jobs**（作业） | 显示 job 格式  |
| `x` | --（无终端）      | 也显示后台或守护进程 |

[root@VM-8-9-centos class11]# ps ajx | head -1 && ps ajx | grep "mypro"
 PPID   PID  PGID   SID TTY      TPGID STAT   UID   TIME COMMAND
  432  1725  1724 32365 pts/2     1724 S+       0   0:00 grep --color=auto mypro
 4183 31761 31761  4183 pts/1    31761 S+       0   0:00 ./mypro
[root@VM-8-9-centos class11]#


kill -9 <PID>

进程在调度运行的时候，进程就具有动态属性。

进程目录
/prc/

程序加载到内存里面，和源文件基本上没关系了。


进程的常见调用信
我们登录的时候，就给你相应的bash. 命令行解释器。
子进程的运行不会影响父进程。

fork之后 会有 父进程 + 子进程。
fork之后 代码被父子共享
根据返回值 不一样，让父子进程执行不同的代码


























    1
