计算密集型 r
IO密集型  s
深度睡眠 d
小t状态,代码调试就是。

zombie僵尸状态
为什么会有僵尸状态
    进程被创建出来---完成任务---1.要知道它完成的如何？2.有些事情可以不关心结果.
                                进程退出的时候，不能立即释放该进程对应的资源。保存一段时间，让父进程或者OS来进行读取。
                                僵尸状态是一个问题，今天我们不解决
孤儿进程
    父进程先退出。他就会被操作系统领养。
    1.这种现象是一定存在的
    2.子进程会被操作系统领养，一号进程。
    3.为什么会被领养，如果不领养，子进程退出的时候，一直是僵尸状态，消耗资源。
    4.孤儿进程会变成后台进程

进程优先级（了解范畴）
    1.什么叫做优先级,先做还是后做的问题。
    2.为什么会存在优先级，因为资源太少。
    3.Linux优先级特点，优先级本质就是PCB里面的一个整数数字（也可能是几个），（ni,pri）linux的优先级 = 老的优先级 + nice 。设置的时候；老的优先级就是80.
    linux支持进程运行中，进行优先级的修改，调整的策略就是修改nice。[-20,19]

1.进程之间具有独立性
2.进程之间具有竞争性
3.并行，多个进程在多个CPU下进行，同时运行。
4.并发，多个程序都能够推进


进程切换
1.CPU里面有很多寄存器，寄存器存放数据的。
2.进程在运行的时候会产生很多的数据。这份数数据属于当前数据。
3.进程不是一直占有CPU到进程结束，死循环会让你滚出去。进程运行时都有时间片。
4.万一时间片没跑完，就被剔除CPU了。产生的数据会被，上下文保护。 这份数据会存放到寄存器里面
5.继续跑程序，产生的数据会被上下文恢复。这份数据存放在寄存器里面
6.进程切换的时候进行上下文保护，进程恢复的时候要进程上下文恢复。
7.

环境变量
   要执行一个程序先要找到一个程序
   ./当路径找到程序
   为什么系统的ls.pwd.which不需要路径
   移动到/usr/bin/下面，但是不建议使用
    echo $PATH 查看环境变量
    添加环境变量
    export PATH= $PATH:
    run commands  运行时的命令

cpu等就r状态，运行队列里面。
设备队列等就是s状态,阻塞状态就是等某种资源，下载软件等网卡资源。
挂起就是短期内不使用，放在外部设备。数据的换入换出。这个状态你不一定知道。系统不一定给你暴露给你。
计算密集型进程非常依赖cpu基本上就是r转态
输出输入密集型继承非常依赖外设基本上就是s状态
t状态就是暂停。
D状态。深度睡眠，这是具体的linux系统。高io情况，不能被杀死。

小t状态：例如gdb调试状态。当前状态正在被追踪。
等待被追踪


X死亡状态：就是状态解释
Z僵尸状态：就是将死状态--僵尸状态。
为什么有将死状态？
创建一个进程状态是为了帮我们解决问题。
进程状态它处理的怎么样了？

nx删除几个字符开，从光标开始的位置。

进程被创建出来是为了完成任务。
1.知道它完成的如何？ 进程退出的时候，不能立即释放该进程对应的资源，保存一段时间,让父进程或者OS来进行读取！
2.有些事情可以不需要关系结果。
linux你可以不要，但是我不能没有。

僵尸状态是一个问题----今天我们不能解决 进程退出，但是没有回收（父进程，OS）

创建子进程，让父进程不要退出而且什么都不用做，让子进程正常退出。

孤儿进程
父进程是bash的子进程
1号进程就是操作系统进程
父进程先走，子进程的父进程变成1就是孤儿继承

1.孤儿进程一定存在
2.子进程汇编操作系统领养--1号进程
3.为什么这样操作，如果不回收，对应的僵尸没有人能够回收
4.被领养的过程--孤儿进程
5.会自动变成后台进程

s:
s+:


进程优先级：了解范畴。
1.什么叫做优先级
    权限：能还是不能
    优先级：现执行还是后执行

2.为什么存在优先级
    因为资源有限
            
3.Linux优先级--很快
    本质就是PCB里面的一个整数（也可能是几个）
    PRID:
    NI:(-20,19)
    最终优先级 == 老的优先级 + NICE linux是支持进程运行中 进行优先级的调整
    老的优先级都是80开始设置

    top指令
    top 
    r

竞争性
独立性：不会互相影响
并行：多个进程同时运行
并发：时间片轮转,进程不断切换

进程切换
寄存器：pc/eip/-->当前指令的下一条指令
CPU:取指令，分析指令，执行指令

进程运行时会产生很多临时数据，这份数据属于当前进程的
寄存器里面保存数据，这份数据属于当前程序的
进程在运行的时候，占有CPU,进程不是一直占有cpu到结束
进程在运行的时候，都有自己的时间片
程序退出时数据保护，程序恢复时数据恢复。
寄存器被所有进程共享，寄存器内的数据，是每个进程各自私有的--上下文数据


环境变量：
    自己写的程序也是指令
    要执行一个程序，先找到一个程序。./当前路径，这就是为什么每次运行都要制定路径
    可以放到/usr/bin/ 下面
    echo $PATH 指令存放的路径
    export PATH = $PATH : 路径






























